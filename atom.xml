<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Daniel Blog</title>
  
  <subtitle>Welcome to my blog</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://hetaotao.net/"/>
  <updated>2021-06-28T10:17:29.883Z</updated>
  <id>http://hetaotao.net/</id>
  
  <author>
    <name>Daniel He</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>Go语言学习</title>
    <link href="http://hetaotao.net/2021/06/28/Go%E8%AF%AD%E8%A8%80%E5%AD%A6%E4%B9%A0/"/>
    <id>http://hetaotao.net/2021/06/28/Go语言学习/</id>
    <published>2021-06-28T10:15:07.163Z</published>
    <updated>2021-06-28T10:17:29.883Z</updated>
    
    <content type="html"><![CDATA[<h1 id="一、Go语言基础">一、Go语言基础</h1><ol><li><p>基础知识</p></li><li><ol><li>Go语言规范</li><li>Go语言命令</li><li>Go语言基础编程</li><li>Go语言并发编程</li></ol></li><li><p>推荐资源</p></li><li><ol><li>Go语言规范文档（英文）：<a href="https://golang.google.cn/ref/spec" target="_blank" rel="noopener">https://golang.google.cn/ref/spec</a></li><li>Go语言命令文档（英文）：<a href="https://golang.google.cn/cmd/go/" target="_blank" rel="noopener">https://golang.google.cn/cmd/go/</a></li><li>Go程序编辑器和IDE（英文）：<a href="https://golang.google.cn/doc/editors" target="_blank" rel="noopener">https://golang.google.cn/doc/editors</a></li><li>Go语言wiki（英文）：<a href="https://github.com/golang/go/wiki" target="_blank" rel="noopener">https://github.com/golang/go/wiki</a></li><li>《Go语言核心技术36讲》：</li><li>《Go并发编程实战》第一版</li><li>《Go命令教程》：</li><li>《Go语言第一课》：<a href="https://www.imooc.com/learn/345" target="_blank" rel="noopener">https://www.imooc.com/learn/345</a></li></ol></li><li><p>更进一步学习</p></li></ol><a id="more"></a><h1 id="二、Go语言进阶">二、Go语言进阶</h1><ol><li><p>进阶知识</p></li><li><ol><li>Go语言数据类型使用进阶</li><li>Go语言标准库使用进阶</li><li>Go语言并发编程进阶</li><li>与前述的各种基础知识融会贯通</li></ol></li><li><p>推荐资源</p></li><li><ol><li>Effective      Go（英文）：</li><li>Go语言内存模型（英文）：</li><li>Go程序诊断（英文）：</li><li>《Go语言核心技术36讲》：</li><li>《Go并发编程实战》第二版</li><li>《Go语言实战》</li></ol></li><li><p>进阶方法</p></li><li><ol><li>打好基础，不断补充知识缺漏</li><li>研读Go语言官方文档和源码</li><li>学习明星项目中的代码和文档</li><li>多读书，读好书（所有相关技术书，不知Go语言）</li><li>积极练习、积极讨论、积极加入技术组织和社区</li><li>积极发布和开源自己的程序，积极通过代码和软件项目交友</li><li>积极公开自己的想法，并拥抱和吸纳不同的想法</li><li>尽量多的在公开场合发声，包括公开讨论、演讲、培训和咨询</li></ol></li></ol><p>来自郝林的Go语言课程。</p>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;一、Go语言基础&quot;&gt;一、Go语言基础&lt;/h1&gt;&lt;ol&gt;
&lt;li&gt;&lt;p&gt;基础知识&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;ol&gt;
&lt;li&gt;Go语言规范&lt;/li&gt;
&lt;li&gt;Go语言命令&lt;/li&gt;
&lt;li&gt;Go语言基础编程&lt;/li&gt;
&lt;li&gt;Go语言并发编程&lt;/li&gt;
&lt;/ol&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;推荐资源&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;ol&gt;
&lt;li&gt;Go语言规范文档（英文）：&lt;a href=&quot;https://golang.google.cn/ref/spec&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;https://golang.google.cn/ref/spec&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;Go语言命令文档（英文）：&lt;a href=&quot;https://golang.google.cn/cmd/go/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;https://golang.google.cn/cmd/go/&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;Go程序编辑器和IDE（英文）：&lt;a href=&quot;https://golang.google.cn/doc/editors&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;https://golang.google.cn/doc/editors&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;Go语言wiki（英文）：&lt;a href=&quot;https://github.com/golang/go/wiki&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;https://github.com/golang/go/wiki&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;《Go语言核心技术36讲》：&lt;/li&gt;
&lt;li&gt;《Go并发编程实战》第一版&lt;/li&gt;
&lt;li&gt;《Go命令教程》：&lt;/li&gt;
&lt;li&gt;《Go语言第一课》：&lt;a href=&quot;https://www.imooc.com/learn/345&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;https://www.imooc.com/learn/345&lt;/a&gt;&lt;/li&gt;
&lt;/ol&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;更进一步学习&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
    
    </summary>
    
      <category term="编程语言" scheme="http://hetaotao.net/categories/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/"/>
    
    
      <category term="编程语言" scheme="http://hetaotao.net/tags/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/"/>
    
  </entry>
  
  <entry>
    <title>优秀技术博客汇总</title>
    <link href="http://hetaotao.net/2020/09/16/%E4%BC%98%E7%A7%80%E6%8A%80%E6%9C%AF%E5%8D%9A%E5%AE%A2%E6%B1%87%E6%80%BB/"/>
    <id>http://hetaotao.net/2020/09/16/优秀技术博客汇总/</id>
    <published>2020-09-16T13:54:00.000Z</published>
    <updated>2021-02-21T17:06:32.621Z</updated>
    
    <content type="html"><![CDATA[<p>到目前看到的我感兴趣的方面比较好的技术博客，不断更新~~<br>主要涉及 Ceph，分布式，运维等方面。</p><a id="more"></a><h1 id="1_Ceph">1 Ceph</h1><p>[1] <a href="https://bean-li.github.io/" target="_blank" rel="noopener">bean-li</a><br>[2] <a href="https://www.cnblogs.com/zphj1987/" target="_blank" rel="noopener">zphj1987</a><br>[3] <a href="http://www.xuxiaopang.com/" target="_blank" rel="noopener">徐小胖</a><br>[4] <a href="http://www.yangguanjun.com/" target="_blank" rel="noopener">ictfox blog</a><br>[5] <a href="https://www.xsky.com/tec/" target="_blank" rel="noopener">XSKY技术文章</a><br>[6] <a href="https://zhuanlan.zhihu.com/p/41909971" target="_blank" rel="noopener">Ceph写放大和性能估算</a><br>[7] <a href="http://www.xuxiaopang.com/2018/03/29/exp-move-ceph-to-new-hosts/#more" target="_blank" rel="noopener">Ceph集群整体迁移</a></p><h1 id="2_分布式">2 分布式</h1><p>[1] <a href="http://drmingdrmer.github.io/" target="_blank" rel="noopener">drdr.xp blog</a><br>[2] <a href="https://www.v2ex.com/t/574537" target="_blank" rel="noopener">v2ex</a><br>[3] <a href="https://blog.openacid.com/algo/paxos/" target="_blank" rel="noopener">xp-可靠分布式系统-paxos的直观解释</a></p><h1 id="3_运维">3 运维</h1><p>[1] <a href="https://www.voidking.com/dev-aiops-summary/" target="_blank" rel="noopener">VoidKing-AIOps</a></p><h1 id="4_数据结构和算法">4 数据结构和算法</h1><p>[1] <a href="https://zhuanlan.zhihu.com/p/98751989" target="_blank" rel="noopener">LSM tree</a></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;到目前看到的我感兴趣的方面比较好的技术博客，不断更新~~&lt;br&gt;主要涉及 Ceph，分布式，运维等方面。&lt;/p&gt;
    
    </summary>
    
      <category term="其他" scheme="http://hetaotao.net/categories/%E5%85%B6%E4%BB%96/"/>
    
    
      <category term="其他" scheme="http://hetaotao.net/tags/%E5%85%B6%E4%BB%96/"/>
    
  </entry>
  
  <entry>
    <title>《思维方式》读书笔记</title>
    <link href="http://hetaotao.net/2020/06/27/%E3%80%8A%E6%80%9D%E7%BB%B4%E6%96%B9%E5%BC%8F%E3%80%8B%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/"/>
    <id>http://hetaotao.net/2020/06/27/《思维方式》读书笔记/</id>
    <published>2020-06-27T14:47:02.000Z</published>
    <updated>2020-08-11T14:29:10.094Z</updated>
    
    <content type="html"><![CDATA[<p>这几天读完了稻盛和夫著、曹寓刚译的《思维方式》，作为一本关于指导或者重塑人生观的书籍，这本书还是相当给予启发的。<br>我觉得可以用一个词总结本书重点： <strong> 利他主义 </strong>，这个也是我印象最深的一点，另外胸怀目标，并不断诉说，同样令我印象深刻。</p><a id="more"></a><p>有趣的是，今天听了马云在上海纽约大学毕业典礼上的演讲中说到了“我们需要三商，需要有IQ（智商），需要EQ（情商），需要LQ（爱商），the Q of Love“。这里的LQ和稻盛和夫先生的利他主义观念可谓英雄所见略同呀。<br>本书的重点总结如下：</p><ol><li><p>稻盛哲学方程式</p><figure class="highlight lsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">人生·工作的结果 = 思维方式 x 热情 (努力) x 能力</span><br><span class="line">   取值范围分别是：  <span class="number">-100</span>~<span class="number">100</span>，  <span class="number">0</span>~<span class="number">100</span>，  <span class="number">0</span>~<span class="number">100</span></span><br></pre></td></tr></table></figure></li><li><p>从9个方面说明美好人生的思维方式<br>包括：胸怀大志、积极向上、不惜努力、诚实正直、钻研创新、愈挫愈勇、心灵纯粹、保持谦虚、利人利世。我觉得这本书应该改名叫《人生观》。</p></li></ol><p>具体的9个方面我影响比较深的原文或者总结如下：<br><strong>胸怀大志：</strong><br>不断诉说公司的宏伟目标，任何事物都需要创造两遍，第一遍是在思想上创造，第二遍是实际创造。<br><strong>积极向上：</strong><br>相信自己的无限的可能性。<br>付出不亚于任何人的努力，专注于一件事。<br>人点燃人，人大致可分为三类：自己就能燃烧的自燃型的人、接近火源就能被点燃的可燃型的人、即使点火也无法燃烧的不燃型的人，我们要成为自燃型的人，即很有能量、积极主动、自我驱动的人。<br>必须在工作的间隙，寻找出喜悦和乐趣，以便持续努力。<br><strong>不惜努力：</strong><br>在人生的旅途中，请大家一定不要选择轻松安逸的道路，一定要迸发热情，付出不亚于任何人的努力，认认真真度过每一天。<br><strong>诚实正直：</strong><br>坚守正道。<br><strong>钻研创新：</strong><br>倾注全力于今天，不断从事创造性的工作。<br><strong>愈挫愈勇：</strong><br>人生不如意十之八九，常想一二。（消业了，应该庆祝）<br><strong>心灵纯粹：</strong><br>人有108种烦恼，其中最厉害的有三种：”欲望” “愚痴” “恼怒”，被称为“三毒”。<br><strong>保持谦虚：</strong><br>不忘谦虚，时时反省，兢兢业业，诚实的度过人生。<br>只有反复学习正确地“哲学”，并将其融入自己的血肉的时候，才能提高“人格”，并将其维持在高水准上。<br><strong>利人利世：</strong><br>人生观第一条：“为世人、为社会尽力，是人最高贵的行为”。<br>一般而言，人往往优先考虑自己，但实际上，每一个人都拥有把“帮助他人，让对方喜悦”作为最高幸福的利他之心。人的本性就是这样美好的东西。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;这几天读完了稻盛和夫著、曹寓刚译的《思维方式》，作为一本关于指导或者重塑人生观的书籍，这本书还是相当给予启发的。&lt;br&gt;我觉得可以用一个词总结本书重点： &lt;strong&gt; 利他主义 &lt;/strong&gt;，这个也是我印象最深的一点，另外胸怀目标，并不断诉说，同样令我印象深刻。&lt;/p&gt;
    
    </summary>
    
      <category term="人生观" scheme="http://hetaotao.net/categories/%E4%BA%BA%E7%94%9F%E8%A7%82/"/>
    
    
      <category term="人生观" scheme="http://hetaotao.net/tags/%E4%BA%BA%E7%94%9F%E8%A7%82/"/>
    
  </entry>
  
  <entry>
    <title>分布式系统MIT6.824学习总结-LECTURE1</title>
    <link href="http://hetaotao.net/2020/06/27/%E5%88%86%E5%B8%83%E5%BC%8F%E7%B3%BB%E7%BB%9FMIT6.824%E5%AD%A6%E4%B9%A0%E6%80%BB%E7%BB%93-LECTURE1/"/>
    <id>http://hetaotao.net/2020/06/27/分布式系统MIT6.824学习总结-LECTURE1/</id>
    <published>2020-06-27T05:12:50.000Z</published>
    <updated>2020-08-11T14:22:05.291Z</updated>
    
    <content type="html"><![CDATA[<h1 id="1-分布式系统工程">1.分布式系统工程</h1><h2 id="分布式系统的目标">分布式系统的目标</h2><ul><li>parallelism (并行，提高性能)</li><li>fault tolerance (容错)</li><li>physical (物理分布，根据实际跨地域的需要)</li><li>security / isolated (安全和隔离)</li></ul><h2 id="挑战">挑战</h2><ul><li>concurrency (并发控制)</li><li>patial failure (部分失败)</li><li>performance (性能)</li></ul><a id="more"></a><h1 id="2-MIT_6-824_课程介绍">2.MIT 6.824 课程介绍</h1><ul><li>lectures</li><li>papers</li><li>exams</li><li>labs</li><li>project (optional)</li></ul><h2 id="实验项目介绍">实验项目介绍</h2><ul><li>lab1: MapReduce</li><li>lab2: Raft for fault tolerance</li><li>lab3: k/v server</li><li>lab4: sharded k/v server</li></ul><h1 id="3-主要课题">3.主要课题</h1><h2 id="涉及到的基础设施">涉及到的基础设施</h2><ul><li>Storage (存储)</li><li>Communication (网络)</li><li>Computation (计算)</li></ul><h2 id="课题">课题</h2><ul><li>实现： PRC, threads, concurrency control</li><li>性能： 可扩展性，性能随节点数按比例提高</li><li>容错： 追求可用性和可恢复性</li><li>一致性： 强一致性和弱一致性</li></ul><h1 id="4-MapReduce">4.MapReduce</h1><h2 id="MapReduce概览">MapReduce概览</h2><p>MapReduce是2004年Google开发，用来建立搜索索引、排序、网页结构分析。<br>这个是大规模分布式计算的代表，目的是提供给用户直接使用分布式计算，而不需要关注底层的分布式实现。<br>MapReduce主要分为 Map 和 Reduce 2个环节，例如对于统计单词出现次数的应用，示例如下：</p><p>Map环节：<br>输入数据是上千个text文件，可以从GFS获取，输出是放在本地的k/v数据。<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Map(k,v)</span><br><span class="line">split v into words</span><br><span class="line">    <span class="keyword">for</span> each word w</span><br><span class="line">    emit(w,<span class="string">"1"</span>)</span><br></pre></td></tr></table></figure></p><p>Reduce环节：<br>输入数据是通过RPC从各个map server上获取的map result，输出是最终统计结果，一般放到GFS。<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Reduce(k,v)</span><br><span class="line">emit(len(v))</span><br></pre></td></tr></table></figure></p><h2 id="MapReduce的优化">MapReduce的优化</h2><p>在2004年，当时的系统瓶颈是网络带宽，为了解决网络带宽的瓶颈做了一些优化，包括：</p><ul><li>将MapReduce部署在GFS的服务器上，将map调度到有输入数据的节点的map worker，通过本地访问数据减少网络传输</li><li>通过Combiner 在map worker node进行局部合并，然后再通过网络发送给 reduce worker(MapReduce论文上的)</li></ul>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;1-分布式系统工程&quot;&gt;1.分布式系统工程&lt;/h1&gt;&lt;h2 id=&quot;分布式系统的目标&quot;&gt;分布式系统的目标&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;parallelism (并行，提高性能)&lt;/li&gt;
&lt;li&gt;fault tolerance (容错)&lt;/li&gt;
&lt;li&gt;physical (物理分布，根据实际跨地域的需要)&lt;/li&gt;
&lt;li&gt;security / isolated (安全和隔离)&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&quot;挑战&quot;&gt;挑战&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;concurrency (并发控制)&lt;/li&gt;
&lt;li&gt;patial failure (部分失败)&lt;/li&gt;
&lt;li&gt;performance (性能)&lt;/li&gt;
&lt;/ul&gt;
    
    </summary>
    
      <category term="分布式" scheme="http://hetaotao.net/categories/%E5%88%86%E5%B8%83%E5%BC%8F/"/>
    
    
      <category term="分布式" scheme="http://hetaotao.net/tags/%E5%88%86%E5%B8%83%E5%BC%8F/"/>
    
  </entry>
  
  <entry>
    <title>IT人都应该了解的存储知识</title>
    <link href="http://hetaotao.net/2020/03/02/IT%E4%BA%BA%E9%83%BD%E5%BA%94%E8%AF%A5%E4%BA%86%E8%A7%A3%E7%9A%84%E5%AD%98%E5%82%A8%E7%9F%A5%E8%AF%86/"/>
    <id>http://hetaotao.net/2020/03/02/IT人都应该了解的存储知识/</id>
    <published>2020-03-02T15:01:48.000Z</published>
    <updated>2020-03-02T15:13:25.964Z</updated>
    
    <content type="html"><![CDATA[<p>存储作为一个非常普遍、非常重要的IT领域，因为其复杂性，可能把很多人拒之门外。所以让非存储领域的IT人都能懂存储是一种需求。本文大致按照历史的脉络来介绍存储系统的发展，希望对大家有帮助。</p><a id="more"></a><h2 id="从一个硬盘说起">从一个硬盘说起</h2><p>从大家接触的第一台台式机或者笔记本电脑开始，就在自己的硬盘上存储信息了，一个硬盘就是我们最早接触的“存储系统”。但是只是硬盘不够靠谱，因为我们知道硬盘损坏也是常有的事。即便现在的硬盘技术也是能够在应对某个局部区域损坏的情况下做出修复，但是无法恢复的故障还是是有发生。怎么在单个硬盘可能存在故障的情况下，仍然保证数据完整呢？</p><h2 id="RAID技术诞生了">RAID技术诞生了</h2><p>为了解决在一个盘故障下的数据保护问题，RAID技术诞生。从1987年刚开始出现到现在RAID技术已经发展了30多年，刚开始的RAID1相当于多写一份，可以允许其中一块盘故障，RAID5利用校验机制降低了RAID1的数据存储成本问题，等等。从RAID的技术发展上我们就可以看出用户对存储系统的几个需求：持久性高、可用性高、性能高、成本低等。但是RAID技术只能解决单机的数据保护，如果一台机器坏了，那这台机器的RAID组可能也会丢失，或者只是一段时间无法访问，但这也足够使我们烦恼。这里我们看到，存储系统地设计初衷，不仅仅面临数据保护问题，而且面临随时需要的数据的读写访问问题。</p><h2 id="单机内冗余机制">单机内冗余机制</h2><p>单机继续演化，从以前的单处理器，单内存条，单网卡，单磁盘阵列，单电源等，到所有组件都有一到多份冗余，即使单个组件，单边访问链路损坏，也不会有数据丢失和数据无法访问的问题。这就是集中式的传统存储系统。从某种程度上说，我们可能满足了所有的存储需求，或者说是满足了某个时代大家对存储系统的需求，毕竟集中式传统存储也已经发展了几十年时间。但是后来互联网、物联网发展起来，数据量呈现爆发式增长，传统集中式存储虽然以其高可靠性、高性能著称，但是其应对超大数据量如何快速扩缩成了问题，而且超大数据量带来的存储成本问题变得非常重要。另外一点，再可靠的单机式存储，在面对机柜、交换机、甚至机房的故障时，也是无能为力的。</p><h2 id="分布式存储">分布式存储</h2><p>快速扩缩容问题、成本问题、更大的故障容忍需求，促使分布式存储出现，并得到快速发展。分布式存储相比传统存储，消除了厂商锁定，更多地依赖于软件，其硬件只是使用通用服务器。正是因为其不用依赖专用硬件，也没有中心节点，其扩容缩容能力很强。按需扩缩容满足了业务需求，也是降低了存储使用成本，以往的硬件lisences成本也省掉了。分布式集群中都是体积较小的通用服务器，可以很容易进行跨机柜、跨交换机、甚至跨机房组建集群，以实现很高的故障容忍能力。当然在满足更多需求的同事，分布式存储也引入了更多需要解决的问题。跨节点的冗余机制和成本问题、节点之间数据量和读写负载均衡问题、扩缩容对线上负载的影响问题，这些都是需要在分布式存储软件上需要解决的。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;存储作为一个非常普遍、非常重要的IT领域，因为其复杂性，可能把很多人拒之门外。所以让非存储领域的IT人都能懂存储是一种需求。本文大致按照历史的脉络来介绍存储系统的发展，希望对大家有帮助。&lt;/p&gt;
    
    </summary>
    
      <category term="storage" scheme="http://hetaotao.net/categories/storage/"/>
    
    
      <category term="storage" scheme="http://hetaotao.net/tags/storage/"/>
    
  </entry>
  
  <entry>
    <title>gdb常用命令备忘</title>
    <link href="http://hetaotao.net/2018/08/28/gdb%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4%E5%A4%87%E5%BF%98/"/>
    <id>http://hetaotao.net/2018/08/28/gdb常用命令备忘/</id>
    <published>2018-08-28T04:01:58.000Z</published>
    <updated>2019-06-28T15:12:41.141Z</updated>
    
    <content type="html"><![CDATA[<p>1、 暂停方式<br>断点 breakpoint / b<br>观察点 watchpoint<br>捕捉点 catchpoint<br>信号 signals<br>线程停止 thread stops<br>恢复程序 continue / c</p><a id="more"></a><p>2、帮助<br>help 命令类别<br>help breakpoint / status / files -&gt;具体命令的帮助</p><p>3、带上调试信息<br>加-g<br>例如：gcc -g hello.c -o hello</p><p>4、常用指令<br>gdb</p><blockquote><p>list<br>break 5<br>break func<br>info break<br>run<br>n / next<br>c / continue<br>p i / print<br>bt 查看函数调用栈<br>finish 退出函数<br>q 退出gdb</p></blockquote>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;1、 暂停方式&lt;br&gt;断点 breakpoint / b&lt;br&gt;观察点 watchpoint&lt;br&gt;捕捉点 catchpoint&lt;br&gt;信号 signals&lt;br&gt;线程停止 thread stops&lt;br&gt;恢复程序 continue / c&lt;/p&gt;
    
    </summary>
    
      <category term="开发工具" scheme="http://hetaotao.net/categories/%E5%BC%80%E5%8F%91%E5%B7%A5%E5%85%B7/"/>
    
    
      <category term="开发工具" scheme="http://hetaotao.net/tags/%E5%BC%80%E5%8F%91%E5%B7%A5%E5%85%B7/"/>
    
  </entry>
  
  <entry>
    <title>leveldb学习总结</title>
    <link href="http://hetaotao.net/2018/08/02/leveldb%E5%AD%A6%E4%B9%A0%E6%80%BB%E7%BB%93/"/>
    <id>http://hetaotao.net/2018/08/02/leveldb学习总结/</id>
    <published>2018-08-02T13:58:23.000Z</published>
    <updated>2018-08-03T03:36:56.897Z</updated>
    
    <content type="html"><![CDATA[<p>这段时间在学习 LevelDB 这个经典的 KV 存储系统，先扔一张自己总结的图，后面有时间主机补充细节。</p><a id="more"></a><p><img src="/uploads/LevelDB学习总结.png" alt="LevelDB"></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;这段时间在学习 LevelDB 这个经典的 KV 存储系统，先扔一张自己总结的图，后面有时间主机补充细节。&lt;/p&gt;
    
    </summary>
    
      <category term="存储" scheme="http://hetaotao.net/categories/%E5%AD%98%E5%82%A8/"/>
    
    
      <category term="存储" scheme="http://hetaotao.net/tags/%E5%AD%98%E5%82%A8/"/>
    
  </entry>
  
  <entry>
    <title>分布式相关学习资料</title>
    <link href="http://hetaotao.net/2018/07/28/%E5%88%86%E5%B8%83%E5%BC%8F%E7%9B%B8%E5%85%B3%E5%AD%A6%E4%B9%A0%E8%B5%84%E6%96%99/"/>
    <id>http://hetaotao.net/2018/07/28/分布式相关学习资料/</id>
    <published>2018-07-28T05:56:52.000Z</published>
    <updated>2020-06-20T08:56:56.261Z</updated>
    
    <content type="html"><![CDATA[<p>最近在网上搜到一些分布式相关的很好的资料，在这里汇总，方便学习和查找。以后不断更新~~</p><a id="more"></a><h1 id="Part-1_分布式存储相关">Part-1 分布式存储相关</h1><p><a href="http://www.open-open.com/lib/view/open1436496725020.html" target="_blank" rel="noopener">分布式存储必读论文</a>，作为一个必读论文清单记录。其中的部分论文我做了下载和整理。如下：<br>[1] <a href="/download/distributed/gfs-sosp2003.pdf">The Google File System. Sanjay Ghemawat, Howard Gobioff, and Shun-Tak Leung</a><br>[2] <a href="/download/distributed/bigtable-osdi06.pdf">Bigtable: A Distributed Storage System for Structured Data. Fay Chang, Jeffrey Dean, Sanjay Ghemawat, et</a><br>[3] <a href="/download/distributed/spanner-osdi2012.pdf">Spanner: Google’s Globally-Distributed Database. James C. Corbett, Jeffrey Dean, et</a><br>[4] <a href="/download/distributed/tr-2008-25.pdf">PacificA: Replication in Log-Based Distributed Storage Systems. Wei Lin, Mao Yang, et</a><br>[5] <a href="/download/distributed/Object-Storage-on-CRAQ.pdf">Object Storage on CRAQ, High-throughput chain replication for read-mostly workloads. Jeff Terrace and Michael J. Freedman</a><br>[6] <a href="/download/distributed/weil-thesis.pdf">Ceph: Reliable, Scalable, and High-Performance Distributed Storage. Sage A. Weil</a><br>[7] <a href="/download/distributed/Finding-a-needle-in-Haystack-Beaver.pdf">Finding a needle in Haystack: Facebook’s photo storage. Doug Beaver, Sanjeev Kumar, Harry C. Li, Jason Sobel, Peter Vajgel</a><br>[8] <a href="/download/distributed/ds-presentation-06-mon-12-windows-azure.pdf">Windows Azure Storage: A Highly Available Cloud Storage Service with Strong Consistency. Brad Calder, Ju Wang, Aaron Ogus, Niranjan Nilakantan, et</a><br>[9] <a href="/download/distributed/chubby-osdi06.pdf">The Chubby lock service for loosely-coupled distributed systems. Mike Burrows</a><br>[10] <a href="/download/distributed/paxos_made_live.pdf">Paxos Made Live – An Engineering Perspective. Tushar Chandra, Robert Griesemer，Joshua Redstone</a><br>[11] <a href="/download/distributed/amazon-dynamo-sosp2007.pdf">Dynamo: Amazon’s Highly Available Key-Value Store。 Giuseppe DeCandia, Deniz Hastorun, Madan Jampani, et</a></p><h1 id="Part-2_分布式系统学习课程">Part-2 分布式系统学习课程</h1><p>MIT 6.824： <a href="https://pdos.csail.mit.edu/6.824/" target="_blank" rel="noopener">https://pdos.csail.mit.edu/6.824/</a></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;最近在网上搜到一些分布式相关的很好的资料，在这里汇总，方便学习和查找。以后不断更新~~&lt;/p&gt;
    
    </summary>
    
      <category term="分布式" scheme="http://hetaotao.net/categories/%E5%88%86%E5%B8%83%E5%BC%8F/"/>
    
    
      <category term="分布式" scheme="http://hetaotao.net/tags/%E5%88%86%E5%B8%83%E5%BC%8F/"/>
    
  </entry>
  
  <entry>
    <title>从虚拟机中的文件到RADOS的object</title>
    <link href="http://hetaotao.net/2018/07/25/%E4%BB%8E%E8%99%9A%E6%8B%9F%E6%9C%BA%E4%B8%AD%E7%9A%84%E6%96%87%E4%BB%B6%E5%88%B0RADOS%E7%9A%84object/"/>
    <id>http://hetaotao.net/2018/07/25/从虚拟机中的文件到RADOS的object/</id>
    <published>2018-07-24T19:17:40.000Z</published>
    <updated>2020-05-27T07:50:12.867Z</updated>
    
    <content type="html"><![CDATA[<h1 id="从虚拟机中的文件到RADOS的object">从虚拟机中的文件到RADOS的object</h1><p>Ceph将虚拟机的卷映射到最终的OSD，经过了两次映射。第一次，从object名到PG做简单hash，并结合pool_id作为前缀，第二次，从PG到OSD通过CRUSH算法计算得到。我们想知道卷最终被映射到哪些主机、哪些OSD、哪些object还是比较麻烦的。<br>我这里摸索出了，从虚拟机的某个文件找到该文件所在rados的object, osd, host的方法 (基于J版Ceph) 。如下：</p><a id="more"></a><p>查看文件的磁盘设备偏移地址<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">[root@vmhost]<span class="meta"># filefrag -v test</span></span><br><span class="line">Filesystem type is: <span class="number">58465342</span></span><br><span class="line">File size of test is <span class="number">35052</span> (<span class="number">9</span> blocks of <span class="number">4096</span> bytes)</span><br><span class="line">ext: logical_offset: physical_offset: length: expected: flags:</span><br><span class="line"><span class="number">0</span>: <span class="number">0.</span>. <span class="number">8</span>: <span class="number">268435473.</span>. <span class="number">268435481</span>: <span class="number">9</span>: eof</span><br></pre></td></tr></table></figure></p><p>根据physical_offset的起始地址 268435473 计算所在的object编号（磁盘设备是顺序切分成object的）<br>268435473/1024 = 262144.0166015625<br>即此从第262144个object开始的,<br>object名字是由prefix和后缀组成的，其中后缀是16进制的，262144转化成16进制为40000。</p><p>查看object的名字<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">[root@server]<span class="meta"># rbd info efs-nfsd-test/quotatest18.img</span></span><br><span class="line">rbd image 'quotatest18.img':</span><br><span class="line">size <span class="number">8192</span> GB in <span class="number">2097152</span> objects</span><br><span class="line">order <span class="number">22</span> (<span class="number">4096</span> kB objects)</span><br><span class="line">block_name_prefix: rbd_data<span class="number">.4</span>d79a4238e1f29</span><br><span class="line">format: <span class="number">2</span></span><br><span class="line">features: layering, exclusive-lock</span><br><span class="line">flags:</span><br></pre></td></tr></table></figure></p><p>找到对应的object prefix为: rbd_data.4d79a4238e1f29 </p><p>通过下面这个命令找到该卷对应的所有的object：<br><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">rados -p efs-nfsd-test ls |grep 'rbd_data.4d79a4238e1f29' &gt;&gt; efs-nfsd-test-objects.txt</span><br></pre></td></tr></table></figure></p><p>在这里面可以找到我们需要的object：rbd_data.4d79a4238e1f29.0000000000040000</p><p>找到对应的object映射到的osd<br><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">[root@server]<span class="meta"># ceph osd map efs-nfsd-test rbd_data.4d79a4238e1f29.0000000000040000</span></span><br><span class="line"></span><br><span class="line">osdmap e188415 pool 'efs-nfsd-test' (16) object 'rbd_data.4d79a4238e1f29.0000000000040000' -&gt; pg 16.4fa43842 (16.42) -&gt; up ([0,20,13], p0) acting ([0,20,13], p0)</span><br></pre></td></tr></table></figure></p><p>从osd找到对应的主机<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[root@server]<span class="meta"># ceph osd tree</span></span><br></pre></td></tr></table></figure></p><p>如果需要可以对object的内容进行验证，导出对应object的内容<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">rados -p efs-nfsd-test get rbd_data<span class="number">.4</span>d79a4238e1f29<span class="number">.0000000000040000</span> rbd_data<span class="number">.4</span>d79a4238e1f29<span class="number">.0000000000040000</span>.txt</span><br></pre></td></tr></table></figure></p><p>用dd可以定位到对应位置的文件内容<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">[root@vmhost]<span class="meta"># dd <span class="meta-keyword">if</span>=rbd_data.4d79a4238e1f29.0000000000040000.txt of=rbd_data.4d79a4238e1f29.0000000000040000_2.txt bs=4k count=9 skip=17</span></span><br><span class="line"><span class="number">9</span>+<span class="number">0</span> records in</span><br><span class="line"><span class="number">9</span>+<span class="number">0</span> records out</span><br><span class="line"><span class="number">36864</span> bytes (<span class="number">37</span> kB) copied, <span class="number">0.000475126</span> s, <span class="number">77.6</span> MB/s</span><br></pre></td></tr></table></figure></p><p>其中skip的数目是以4k为单位的，可以从开始的filefrag -v test的数字计算出来<br>268435473-262144*1024=17<br>可以看到从object导出的文件内容和实际的文件内容是一致的。</p>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;从虚拟机中的文件到RADOS的object&quot;&gt;从虚拟机中的文件到RADOS的object&lt;/h1&gt;&lt;p&gt;Ceph将虚拟机的卷映射到最终的OSD，经过了两次映射。第一次，从object名到PG做简单hash，并结合pool_id作为前缀，第二次，从PG到OSD通过CRUSH算法计算得到。我们想知道卷最终被映射到哪些主机、哪些OSD、哪些object还是比较麻烦的。&lt;br&gt;我这里摸索出了，从虚拟机的某个文件找到该文件所在rados的object, osd, host的方法 (基于J版Ceph) 。如下：&lt;/p&gt;
    
    </summary>
    
      <category term="ceph" scheme="http://hetaotao.net/categories/ceph/"/>
    
    
      <category term="ceph" scheme="http://hetaotao.net/tags/ceph/"/>
    
  </entry>
  
  <entry>
    <title>Git入门之同步上游代码</title>
    <link href="http://hetaotao.net/2018/07/24/Git%E5%85%A5%E9%97%A8%E4%B9%8B%E5%90%8C%E6%AD%A5%E4%B8%8A%E6%B8%B8%E4%BB%A3%E7%A0%81/"/>
    <id>http://hetaotao.net/2018/07/24/Git入门之同步上游代码/</id>
    <published>2018-07-24T04:52:57.000Z</published>
    <updated>2020-05-27T07:39:03.840Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Git_入门之同步上游代码">Git 入门之同步上游代码</h1><p>作为开源社区的贡献者，我们经常需要将自己的Github仓库从社区同步。这里从网上查，加上自己实践总结一下方法。</p><a id="more"></a><h2 id="同步上游的代码到自己的仓库，并提交到自己的Github仓库">同步上游的代码到自己的仓库，并提交到自己的Github仓库</h2><p>添加一个upstream仓库</p><blockquote><p>git remote add upstream &lt;原作者项目的URL&gt;</p></blockquote><p>查看已经添加的上游仓库</p><blockquote><p>git remote -v</p></blockquote><p>这里比如说添加ceph的上游社区仓库：</p><blockquote><p>git remote add ceph_upstream  <a href="https://github.com/ceph/ceph.git" target="_blank" rel="noopener">https://github.com/ceph/ceph.git</a></p></blockquote><p>将上游的项目更新到本地</p><blockquote><p>git fetch ceph_upstream</p></blockquote><p>选择本地的master分支</p><blockquote><p>git checkout master</p></blockquote><p>将本地的分支与ceph_upstream的master分支合并</p><blockquote><p>git merge ceph_upstream/master</p></blockquote><p>将本地的内容提交到自己的Github仓库</p><blockquote><p>git remote -v<br>git push <a href="mailto:git@github.com" target="_blank" rel="noopener">git@github.com</a>:&lt;Github用户&gt;/ceph.git</p></blockquote><p>参考：<br><a href="https://blog.csdn.net/sjt19910311/article/details/50596714" target="_blank" rel="noopener">https://blog.csdn.net/sjt19910311/article/details/50596714</a> </p>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;Git_入门之同步上游代码&quot;&gt;Git 入门之同步上游代码&lt;/h1&gt;&lt;p&gt;作为开源社区的贡献者，我们经常需要将自己的Github仓库从社区同步。这里从网上查，加上自己实践总结一下方法。&lt;/p&gt;
    
    </summary>
    
      <category term="开发工具" scheme="http://hetaotao.net/categories/%E5%BC%80%E5%8F%91%E5%B7%A5%E5%85%B7/"/>
    
    
      <category term="开发工具" scheme="http://hetaotao.net/tags/%E5%BC%80%E5%8F%91%E5%B7%A5%E5%85%B7/"/>
    
  </entry>
  
  <entry>
    <title>shell学习</title>
    <link href="http://hetaotao.net/2018/06/22/shell%E5%AD%A6%E4%B9%A0/"/>
    <id>http://hetaotao.net/2018/06/22/shell学习/</id>
    <published>2018-06-22T04:40:37.000Z</published>
    <updated>2020-05-27T07:46:05.244Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Shell_学习">Shell 学习</h1><p>因为平时写 Shell 脚本比较多，并且 Shell 的语法规则比较零散，这里做一些学习和实践总结。</p><a id="more"></a><h2 id="Shell_字典">Shell 字典</h2><p><strong>字典的声明</strong><br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">declare -A all_service</span><br></pre></td></tr></table></figure></p><p><strong>字典的赋值</strong><br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">all_service=([key1]=<span class="string">"value1"</span> [key2]=<span class="string">"value2"</span> [key3]=<span class="string">"vlaue3"</span>)</span><br></pre></td></tr></table></figure></p><p><strong>字典的取值</strong></p><p>取 value 值<br>如取 key1 对应的 value1：<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$&#123;all_service[key1]&#125;</span><br></pre></td></tr></table></figure></p><p>如取所有的 value：<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$&#123;all_service[*]&#125;</span><br></pre></td></tr></table></figure></p><p>取key值<br>如取所有的 key：<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$&#123;!all_service[*]&#125;</span><br></pre></td></tr></table></figure></p><p><strong>示例</strong><br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">#!/bin/bash</span><br><span class="line"></span><br><span class="line">declare -A all_service</span><br><span class="line">all_service=([ntpd]=<span class="string">"on"</span> [lldpad]=<span class="string">"on"</span> [firewalld]=<span class="string">"off"</span>)</span><br><span class="line">echo <span class="string">"---Get value1---"</span></span><br><span class="line">echo $&#123;all_service[ntpd]&#125;</span><br><span class="line"></span><br><span class="line">echo <span class="string">"---Get all values---"</span></span><br><span class="line">echo $&#123;all_service[*]&#125;</span><br><span class="line"></span><br><span class="line">echo <span class="string">"---Get all keys---"</span></span><br><span class="line">echo $&#123;!all_service[*]&#125;</span><br><span class="line"></span><br><span class="line">echo <span class="string">"---Get all key:value pairs---"</span></span><br><span class="line"><span class="keyword">for</span> services in $(echo $&#123;!all_service[*]&#125;);</span><br><span class="line"><span class="keyword">do</span></span><br><span class="line">        echo <span class="string">"$&#123;services&#125; : $&#123;all_service[$&#123;services&#125;]&#125;"</span></span><br><span class="line">done</span><br></pre></td></tr></table></figure></p><p>运行结果<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">&gt;sh test.sh</span><br><span class="line">---Get value1---</span><br><span class="line">on</span><br><span class="line">---Get all values---</span><br><span class="line">on on off</span><br><span class="line">---Get all keys---</span><br><span class="line">lldpad ntpd firewalld</span><br><span class="line">---Get all key:value pairs---</span><br><span class="line">lldpad : on</span><br><span class="line">ntpd : on</span><br><span class="line">firewalld : off</span><br></pre></td></tr></table></figure></p><p><strong>参考</strong><br>[1] <a href="https://blog.csdn.net/jeremy_yangt/article/details/49100773" target="_blank" rel="noopener">https://blog.csdn.net/jeremy_yangt/article/details/49100773</a><br>[2] <a href="https://blog.csdn.net/u014297722/article/details/54601660?utm_source=itdadao&amp;utm_medium=referral" target="_blank" rel="noopener">https://blog.csdn.net/u014297722/article/details/54601660?utm_source=itdadao&amp;utm_medium=referral</a></p>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;Shell_学习&quot;&gt;Shell 学习&lt;/h1&gt;&lt;p&gt;因为平时写 Shell 脚本比较多，并且 Shell 的语法规则比较零散，这里做一些学习和实践总结。&lt;/p&gt;
    
    </summary>
    
      <category term="编程" scheme="http://hetaotao.net/categories/%E7%BC%96%E7%A8%8B/"/>
    
    
      <category term="shell" scheme="http://hetaotao.net/tags/shell/"/>
    
  </entry>
  
  <entry>
    <title>SRE</title>
    <link href="http://hetaotao.net/2018/06/10/SRE/"/>
    <id>http://hetaotao.net/2018/06/10/SRE/</id>
    <published>2018-06-10T02:01:19.000Z</published>
    <updated>2020-05-27T07:47:15.950Z</updated>
    
    <content type="html"><![CDATA[<p>从 2016 年底就开始阅读 《SRE Google 运维解密》 这本书，断断续续看得差不多。对于 Google 这种超大规模的互联网公司，他的运维体系在相当长的时间内都是领先业界很多，虽然说其公开的资料已经是 Google 几年前的事情了，但是其体系还是有很大的研究和实践价值。<br>这本书的重点是指导思想+具体实践，其中的关键词是分布式。众所周知，Google 在分布式系统方面的理论和实践相当先进，其分布式存储 GFS、分布式计算 MapReduce，分布式数据库 BigTable 也是被广泛地研究与学习。</p><a id="more"></a><p>现在开始进入正文，什么是 SRE ？<br>SRE 的全称是 Site Reliability Engineering，直译是“站点可靠性工程师”。他承担运维工作，但不是传统意义上的运维工程师。<br>SRE 的要务：<br>（1） 确保长期参与研发工作<br>（2） 在保障服务 SLO 的前提下最大化迭代速度<br>（3） 监控系统<br>（4） 应急事件处理<br>（5） 变更管理<br>（6） 需求预测和容量规划<br>（7） 资源部署<br>（8） 效率与性能</p><h1 id="指导思想">指导思想</h1><p>SRE 其实是 DevOps 的一种具体实践。<br><img src="/uploads/SRE/512px-Devops-toolchain.svg.png" alt="DevOps"></p><center>图一</center><p>Dev，致力于快速发布新特性；Ops，致力于生产系统的稳定可用。两者结合解决了开发和运维之间的矛盾，并且统一了团队的目标，即：在保障服务 SLO （服务等级目标） 的前提下最大化迭代速度。<br>下表描述了 DevOps 五大支柱和相对应的 SRE 实践：</p><table><thead><tr><th style="text-align:center">DevOps</th><th>SRE</th></tr></thead><tbody><tr><td style="text-align:center">减少组织内的孤立</td><td>通过在整个技术栈使用同样的工具和技术来与开发者一同承担</td></tr><tr><td style="text-align:center">接受失效是常态</td><td>使用一个公式在新版本发布和事故/失效之间做平衡</td></tr><tr><td style="text-align:center">实现渐进式变更</td><td>实现渐进式变更</td></tr><tr><td style="text-align:center">使用工具和自动化</td><td>鼓励“将今年的工作自动化掉”，最少化人工操作，以此将精力集中到能给系统带来长期价值的工作上</td></tr><tr><td style="text-align:center">测量一切</td><td>坚信运维是一个软件问题。定义标准化的方法来测量可用性，运行时间，中断和苦力</td></tr></tbody></table><center>表一</center><h2 id="1_风险管理">1 风险管理</h2><p>首先，我们需要考虑系统的可用性是什么。SRE 给出了如下两个公式：<br>（1） 可用性 = 系统正常运行时间 / （系统正常运行时间+停机时间）<br>（2） 可用性 = 成功请求数 / 总的请求数<br>用户的需求以及SLO确定的可用性是很高的，但是并不是意味着我们不能一味地追求最高的可用性，我们还需要考虑成本和迭代速度。如下：<br>可用性： 99.99% —-&gt;  99.99(…n个9)%<br>成本：       c1 —-&gt;  c1*b^n  ~ inf<br>迭代速度：    s1 —-&gt;  s1/b^n  ~ 0<br>即：在可用性提高的同时，相应的系统成本就会显著提高、版本的迭代速度就会显著的下降。（这里的公式只是代表趋势，不能做实际的数值计算）</p><h2 id="2_减少琐事">2 减少琐事</h2><p><strong>何为琐事？</strong></p><blockquote><p>琐事就是运维服务中手动性的，重复性的，可以被自动化的，战术性，没有持久价值的工作。而且，琐事与服务呈线性关系的增长。</p></blockquote><p>手动性的：手动执行一些命令或者脚本。<br>重复性的：需要不停地反复做的事情。<br>可以被自动化的：如果计算机和人类一样可以完成某个任务。<br>战术性的：突然出现的应对式的工作，而非计划内安排的。如处理紧急警报。<br>没有持久价值：并非对服务带来永久性改进的工作。<br>与服务同步线性增长：如果工作所涉及的任务与服务的大小、流量或用户数量呈线性增长关系，那这项任务可能就属于琐事。</p><p><strong>为什么要减少琐事？</strong></p><blockquote><p>SRE 的一个公开的目标是保持每个 SRE 的工作时间中运维工作（即琐事）的比例低于 50% 。SRE 至少是 50% 的时间花在工程项目上，以减少未来的琐事或者增加服务功能。增加服务功能包括提高可靠性、性能、或利用率，同时也会进一步消除琐事。</p></blockquote><p><strong>什么是工程项目工作？</strong><br>工程项目工作是有创新性和创造性的，着重通过设计来解决问题。工程工作有助于团队在维持同等人员配备的情况下接手更大或者更多的服务。</p><p>典型的 SRE 活动分为如下几类：<br><strong>软件工程</strong> —— 编写或者修改代码，以及所有其他相关的设计和文档工作。包括：项目特性代码，自动化脚本、工具代码等。<br><strong>系统工程</strong> —— 配置、部署、更新等。<br><strong>琐事</strong> —— 与运维相关的重复性的、手工的劳动。<br><strong>流程负担</strong> —— 会议、总结、招聘、培训等。</p><h2 id="3_自动化">3 自动化</h2><p><strong>自动化的价值</strong></p><ul><li>操作的一致性，避免不同人不同时候做同一项配置的不同操作。</li><li>平台性，错误集中化，降低对人的依赖与要求（随时、频繁、精确）。</li><li>修复速度更快，有时候能够有效地降低 MTTR 。</li><li>节省时间，一个自动化系统可以被多次、多人执行。避免用人类的鲜血、汗水和眼泪来养活机器。</li></ul><p>另外，通过一下这个图我们可以大致决定我们的工作是否需要被自动化。<br><img src="/uploads/SRE/is_it_worth_the_time.png" alt="DevOps"></p><center>图二 (From <a href="https://xkcd.com/1205/" target="_blank" rel="noopener">https://xkcd.com/1205/</a>)</center><p>注：横轴表示任务执行的频率，纵轴表示每次任务执行时间，单元格表示 5 年的时间内，任务执行下来需要花费的时间。左下角的任务是花费时间最长的任务，是需要优先被自动化的任务。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;从 2016 年底就开始阅读 《SRE Google 运维解密》 这本书，断断续续看得差不多。对于 Google 这种超大规模的互联网公司，他的运维体系在相当长的时间内都是领先业界很多，虽然说其公开的资料已经是 Google 几年前的事情了，但是其体系还是有很大的研究和实践价值。&lt;br&gt;这本书的重点是指导思想+具体实践，其中的关键词是分布式。众所周知，Google 在分布式系统方面的理论和实践相当先进，其分布式存储 GFS、分布式计算 MapReduce，分布式数据库 BigTable 也是被广泛地研究与学习。&lt;/p&gt;
    
    </summary>
    
      <category term="运维" scheme="http://hetaotao.net/categories/%E8%BF%90%E7%BB%B4/"/>
    
    
      <category term="运维" scheme="http://hetaotao.net/tags/%E8%BF%90%E7%BB%B4/"/>
    
  </entry>
  
  <entry>
    <title>osd故障检测机制小结</title>
    <link href="http://hetaotao.net/2018/04/11/osd%E6%95%85%E9%9A%9C%E6%A3%80%E6%B5%8B%E6%9C%BA%E5%88%B6%E5%B0%8F%E7%BB%93/"/>
    <id>http://hetaotao.net/2018/04/11/osd故障检测机制小结/</id>
    <published>2018-04-11T12:27:40.000Z</published>
    <updated>2020-05-27T07:45:21.131Z</updated>
    
    <content type="html"><![CDATA[<h1 id="osd故障检测机制小结">osd故障检测机制小结</h1><p>从3条简要的代码线看osd的故障检测机制。</p><a id="more"></a><p><img src="/uploads/osd故障检测机制.png" alt="storage"></p>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;osd故障检测机制小结&quot;&gt;osd故障检测机制小结&lt;/h1&gt;&lt;p&gt;从3条简要的代码线看osd的故障检测机制。&lt;/p&gt;
    
    </summary>
    
      <category term="ceph" scheme="http://hetaotao.net/categories/ceph/"/>
    
    
      <category term="ceph" scheme="http://hetaotao.net/tags/ceph/"/>
    
  </entry>
  
  <entry>
    <title>ceph-heartbeat3</title>
    <link href="http://hetaotao.net/2017/12/20/ceph-heartbeat3/"/>
    <id>http://hetaotao.net/2017/12/20/ceph-heartbeat3/</id>
    <published>2017-12-20T13:30:58.000Z</published>
    <updated>2020-05-27T07:38:19.888Z</updated>
    
    <content type="html"><![CDATA[<h1 id="ceph集群中的心跳机制研究3">ceph集群中的心跳机制研究3</h1><p>之前研究了Ceph集群的心跳机制和故障检测机制，那从心跳机制到故障判断的过程又是什么样的？因为涉及多个源代码文件，并且函数调用嵌套很多层，这里看起来不是那么清晰，所以这也是我最后要讲的地方。</p><a id="more"></a><h2 id="从heartbeat_check_no_reply到最终确定osd_failure的过程">从heartbeat check no reply到最终确定osd failure的过程</h2><p>heartbeat的相关实现在源文件OSD.cc中。<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">OSD::heartbeat() </span><br><span class="line">(send heartbeats) -&gt; OSD::heartbeat_check()</span><br><span class="line">...</span><br><span class="line">(省略一些中间过程)</span><br><span class="line">OSD::send_failures() -&gt; 依据failure_queue计算failed_for -&gt; 带上failed_for，通过MOSDFailure包装(带上标志MSG_OSD_FAILURE)，然后发送msg给mon，failed_for是OSD failed的时间长度。如下：</span><br><span class="line">monc-&gt;send_mon_message(<span class="keyword">new</span> MOSDFailure(monc-&gt;get_fsid(), i, failed_for,</span><br><span class="line">     osdmap-&gt;get_epoch()));</span><br></pre></td></tr></table></figure></p><p>然后在源文件OSDMonitor.cc中进行处理。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">OSDMonitor::prepare_update() -&gt; <span class="keyword">case</span> MSG_OSD_FAILURE ，它接受一个op参数，然后进入<span class="keyword">switch</span>，如下：</span><br><span class="line"><span class="keyword">bool</span> OSDMonitor::prepare_update(MonOpRequestRef op)</span><br><span class="line">&#123;</span><br><span class="line">  op-&gt;mark_osdmon_event(__func__);</span><br><span class="line">  PaxosServiceMessage *m = <span class="keyword">static_cast</span>&lt;PaxosServiceMessage*&gt;(op-&gt;get_req());</span><br><span class="line">  dout(<span class="number">7</span>) &lt;&lt; <span class="string">"prepare_update "</span> &lt;&lt; *m &lt;&lt; <span class="string">" from "</span> &lt;&lt; m-&gt;get_orig_source_inst() &lt;&lt; dendl;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">switch</span> (m-&gt;get_type()) &#123;</span><br><span class="line">    <span class="comment">// damp updates</span></span><br><span class="line">  <span class="keyword">case</span> MSG_OSD_MARK_ME_DOWN:</span><br><span class="line">    <span class="keyword">return</span> prepare_mark_me_down(op);</span><br><span class="line">  <span class="keyword">case</span> MSG_OSD_FAILURE:</span><br><span class="line">    <span class="keyword">return</span> prepare_failure(op);</span><br><span class="line">...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>最后在进入以下故障判定的两个阶段：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">OSDMonitor::prepare_failure()</span><br><span class="line">OSDMinitor::check_failure()</span><br></pre></td></tr></table></figure><p>2017年12月20日</p>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;ceph集群中的心跳机制研究3&quot;&gt;ceph集群中的心跳机制研究3&lt;/h1&gt;&lt;p&gt;之前研究了Ceph集群的心跳机制和故障检测机制，那从心跳机制到故障判断的过程又是什么样的？因为涉及多个源代码文件，并且函数调用嵌套很多层，这里看起来不是那么清晰，所以这也是我最后要讲的地方。&lt;/p&gt;
    
    </summary>
    
      <category term="ceph" scheme="http://hetaotao.net/categories/ceph/"/>
    
    
      <category term="ceph" scheme="http://hetaotao.net/tags/ceph/"/>
    
  </entry>
  
  <entry>
    <title>ceph-heartbeat2</title>
    <link href="http://hetaotao.net/2017/11/24/ceph-heartbeat2/"/>
    <id>http://hetaotao.net/2017/11/24/ceph-heartbeat2/</id>
    <published>2017-11-24T12:09:50.000Z</published>
    <updated>2020-05-27T07:37:53.731Z</updated>
    
    <content type="html"><![CDATA[<h1 id="ceph集群中的心跳机制研究2">ceph集群中的心跳机制研究2</h1><p>我知道Ceph的基石是RADOS，而RADOS的含义是Reliable Autonomic Distributed Object Storage，而Autonomic（自治）的实现则依赖于Ceph中很好的故障检测机制。<br>下面进入正题。</p><a id="more"></a><p>Ceph在故障检测的时候有两个函数：<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">OSDMonitor::check_failure</span><br><span class="line">OSDMonitor::prepare_failure</span><br></pre></td></tr></table></figure></p><p>他们之间的关系是，prepare_failure做了一些fail前的report过程，然后再调用check_failure。</p><h2 id="grace_time">grace time</h2><p>对于osd的故障判断有个grace time，相当于一个容错值，当fail time大于grace time时基本可以断定osd fail。当配置项g_conf-&gt;mon_osd_adjust_heartbeat_grace为true的时候，grace的计算有个过程，并且这个过程让人难以理解，先贴一下代码。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//my_grace计算</span></span><br><span class="line">    <span class="keyword">double</span> halflife = (<span class="keyword">double</span>)g_conf-&gt;mon_osd_laggy_halflife;</span><br><span class="line">    <span class="keyword">double</span> decay_k = ::<span class="built_in">log</span>(<span class="number">.5</span>) / halflife;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// scale grace period based on historical probability of 'lagginess'</span></span><br><span class="line">    <span class="comment">// (false positive failures due to slowness).</span></span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">osd_xinfo_t</span>&amp; xi = osdmap.get_xinfo(target_osd);</span><br><span class="line">    <span class="keyword">double</span> decay = <span class="built_in">exp</span>((<span class="keyword">double</span>)failed_for * decay_k);</span><br><span class="line">    dout(<span class="number">20</span>) &lt;&lt; <span class="string">" halflife "</span> &lt;&lt; halflife &lt;&lt; <span class="string">" decay_k "</span> &lt;&lt; decay_k</span><br><span class="line">     &lt;&lt; <span class="string">" failed_for "</span> &lt;&lt; failed_for &lt;&lt; <span class="string">" decay "</span> &lt;&lt; decay &lt;&lt; dendl;</span><br><span class="line">    my_grace = decay * (<span class="keyword">double</span>)xi.laggy_interval * xi.laggy_probability;</span><br><span class="line">    grace += my_grace;</span><br><span class="line"></span><br><span class="line"><span class="comment">//peer_grace计算</span></span><br><span class="line">    assert(fi.reporters.size());</span><br><span class="line">    <span class="keyword">for</span> (<span class="built_in">map</span>&lt;<span class="keyword">int</span>,<span class="keyword">failure_reporter_t</span>&gt;::iterator p = fi.reporters.begin();</span><br><span class="line"> p != fi.reporters.end();</span><br><span class="line"> ++p) &#123;</span><br><span class="line">      <span class="keyword">const</span> <span class="keyword">osd_xinfo_t</span>&amp; xi = osdmap.get_xinfo(p-&gt;first);</span><br><span class="line">      <span class="keyword">utime_t</span> elapsed = now - xi.down_stamp;</span><br><span class="line">      <span class="keyword">double</span> decay = <span class="built_in">exp</span>((<span class="keyword">double</span>)elapsed * decay_k);</span><br><span class="line">      peer_grace += decay * (<span class="keyword">double</span>)xi.laggy_interval * xi.laggy_probability;</span><br><span class="line">    &#125;</span><br><span class="line">    peer_grace /= (<span class="keyword">double</span>)fi.reporters.size();</span><br><span class="line">    grace += peer_grace;</span><br></pre></td></tr></table></figure><h2 id="失效条件">失效条件</h2><p>重点在这里，最终check_failure的成功条件是：<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">failed_for &gt;= grace &amp;&amp; </span><br><span class="line">((<span class="keyword">int</span>)fi.reporters.size() &gt;= g_conf-&gt;mon_osd_min_down_reporters) &amp;&amp;</span><br><span class="line">(fi.num_reports &gt;= g_conf-&gt;mon_osd_min_down_reports)</span><br></pre></td></tr></table></figure></p><p>即失效时间大于grace(g_conf中设置的值)，并且reporters大于配置的reporters，reports大于配置的reports。<br>当这3个条件同时满足后osd会被标记为down,并输出类似如下这样的日志：<br>osd.3 failed 3 reports from 1 peers after 21.666000 &gt;= grace 20</p><h3 id="注(2018年1月13日)：">注(2018年1月13日)：</h3><p>以上对于Ceph 0.94.5版本，对于Ceph10.2.10 Jewel版本，mark down的机制有所不同，条件从3个变成两个了，代码如下：<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (failed_for &gt;= grace &amp;&amp;</span><br><span class="line">    (<span class="keyword">int</span>)reporters_by_subtree.size() &gt;= g_conf-&gt;mon_osd_min_down_reporters)</span><br></pre></td></tr></table></figure></p><p>即grace time超时，并且来自不同subtree的reporters达到了配置的数目。<br>相关的两个集群配置为：<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">mon_osd_min_down_reporters，默认<span class="number">2</span></span><br><span class="line">mon_osd_reporter_subtree_level，默认为host</span><br></pre></td></tr></table></figure></p><h2 id="grace值的tradeoff">grace值的tradeoff</h2><p>这个值可以在集群动态配置，默认是20s。如果值设置地过大，那么当集群出现节点故障时，集群的故障判断时间势必会很长，这直接导致客户端的IO相应地阻塞很长时间。如果值设置的过小也是可能会出问题的，因为分布式集群不可避免地会遇到节点之间的网络问题，当网络出现短时间的丢包或者阻塞的时候，过小的grace设置会导致集群很快认为osd down，尽管网络只是暂时的抖动。从这里可以看出来，对于分布式系统的3个状态：成功，失败和超时，其中失败和超时之间并没有严格的界限，需要我们自己去权衡。</p><p>2017年11月24日</p>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;ceph集群中的心跳机制研究2&quot;&gt;ceph集群中的心跳机制研究2&lt;/h1&gt;&lt;p&gt;我知道Ceph的基石是RADOS，而RADOS的含义是Reliable Autonomic Distributed Object Storage，而Autonomic（自治）的实现则依赖于Ceph中很好的故障检测机制。&lt;br&gt;下面进入正题。&lt;/p&gt;
    
    </summary>
    
      <category term="ceph" scheme="http://hetaotao.net/categories/ceph/"/>
    
    
      <category term="ceph" scheme="http://hetaotao.net/tags/ceph/"/>
    
  </entry>
  
  <entry>
    <title>ceph heartbeat</title>
    <link href="http://hetaotao.net/2017/09/06/ceph-heartbeat/"/>
    <id>http://hetaotao.net/2017/09/06/ceph-heartbeat/</id>
    <published>2017-09-06T15:25:17.000Z</published>
    <updated>2020-05-27T07:22:00.967Z</updated>
    
    <content type="html"><![CDATA[<h1 id="ceph集群中的心跳机制研究">ceph集群中的心跳机制研究</h1><p>基于Ceph 0.94.5版本，进行Ceph集群中的心跳机制进行研究。<br>在ceph中，心跳机制通过ping来实现，用来作为集群中故障检测的方法。分为两类：osd与osd之间的心跳，osd与mon之间的心跳。下面去一探究竟。</p><a id="more"></a><h2 id="osd与osd之间的心跳">osd与osd之间的心跳</h2><p>1、相邻osd之间会维持心跳，默认情况下，时间间隔是6s。<br>2、一个osd上面的pg所关联的osd之间存在着心跳。<br>所谓相邻，即根据osd的ID，该osd前一个活着的osd和后一个活着的osd。</p><p>如果一个osd在20s的grace时间内，没有收到来自邻居osd的heartbeat，那么它认为这个邻居osd down，并且汇报给monitor。<br>如果来自不同主机的2个osd报告同一个osd down，那么monitor承认这个osd down。</p><p>如下，从update_heartbeat_peers这个函数可以看出第2个选peers的方式。即有效的acting_set和up_set中出现的osd将被加入peers，但是涉及到 map pg_shard_t,pg_info_t &gt; 的加入方式并没有看懂，进一步研究。<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span> PG::update_heartbeat_peers()</span><br><span class="line">&#123;</span><br><span class="line">  assert(is_locked());</span><br><span class="line"></span><br><span class="line">  <span class="built_in">set</span>&lt;<span class="keyword">int</span>&gt; new_peers;</span><br><span class="line">  <span class="keyword">if</span> (is_primary()) &#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">unsigned</span> i=<span class="number">0</span>; i&lt;acting.size(); i++) &#123;</span><br><span class="line">      <span class="keyword">if</span> (acting[i] != CRUSH_ITEM_NONE)</span><br><span class="line">new_peers.insert(acting[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">unsigned</span> i=<span class="number">0</span>; i&lt;up.size(); i++) &#123;</span><br><span class="line">      <span class="keyword">if</span> (up[i] != CRUSH_ITEM_NONE)</span><br><span class="line">new_peers.insert(up[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="built_in">map</span>&lt;<span class="keyword">pg_shard_t</span>,<span class="keyword">pg_info_t</span>&gt;::iterator p = peer_info.begin();</span><br><span class="line"> p != peer_info.end();</span><br><span class="line"> ++p)</span><br><span class="line">      new_peers.insert(p-&gt;first.osd);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">bool</span> need_update = <span class="literal">false</span>;</span><br><span class="line">  heartbeat_peer_lock.Lock();</span><br><span class="line">  <span class="keyword">if</span> (new_peers == heartbeat_peers) &#123;</span><br><span class="line">    dout(<span class="number">10</span>) &lt;&lt; <span class="string">"update_heartbeat_peers "</span> &lt;&lt; heartbeat_peers &lt;&lt; <span class="string">" unchanged"</span> &lt;&lt; dendl;</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    dout(<span class="number">10</span>) &lt;&lt; <span class="string">"update_heartbeat_peers "</span> &lt;&lt; heartbeat_peers &lt;&lt; <span class="string">" -&gt; "</span> &lt;&lt; new_peers &lt;&lt; dendl;</span><br><span class="line">    heartbeat_peers.swap(new_peers);</span><br><span class="line">    need_update = <span class="literal">true</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  heartbeat_peer_lock.Unlock();</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (need_update)</span><br><span class="line">    osd-&gt;need_heartbeat_peer_update();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h2 id="osd与mon之间的心跳">osd与mon之间的心跳</h2><p>如果一个osd无法peer其他所有的osd，osd每30s ping一次monitor，并且获取最新的cluster map信息。<br>如果osd没有主动报告monitor，那么monitor会在mon_osd_report_time时间后认为osd down。对应2个时间mon_osd_report_interval_min, mon_osd_report_interval_max。在达到interval_max的时候，不管有没有改变，osd都会主动上报给monitor。</p><p>osd在如下几种情况下会主动上报monitor：<br>有失效的情况，pg状态的改变，up_thru的改变，osd在boot的5s时间以内。<br>如果osd发现他的peers为空的时候，也会主动发送hb给monitor，并且获取新的osdmap（osdmap_subscribe）。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">HeartbeatInfo</span> &#123;</span></span><br><span class="line">    <span class="keyword">int</span> peer;           <span class="comment">///&lt; peer</span></span><br><span class="line">    ConnectionRef con_front;   <span class="comment">///&lt; peer connection (front)</span></span><br><span class="line">    ConnectionRef con_back;    <span class="comment">///&lt; peer connection (back)</span></span><br><span class="line">    <span class="keyword">utime_t</span> first_tx;   <span class="comment">///&lt; time we sent our first ping request</span></span><br><span class="line">    <span class="keyword">utime_t</span> last_tx;    <span class="comment">///&lt; last time we sent a ping request</span></span><br><span class="line">    <span class="keyword">utime_t</span> last_rx_front;  <span class="comment">///&lt; last time we got a ping reply on the front side</span></span><br><span class="line">    <span class="keyword">utime_t</span> last_rx_back;   <span class="comment">///&lt; last time we got a ping reply on the back side</span></span><br><span class="line">    <span class="keyword">epoch_t</span> epoch;      <span class="comment">///&lt; most recent epoch we wanted this peer</span></span><br><span class="line">   ......</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>HeartbeatInfo结构体中包括：con_front表示前向的连接，即public network的连接，con_back表示后向连接，即cluster network的连接。当一个osd发送ping心跳报文的时候，会通过后向连接发送，如果前向连接有效，也通过前向连接发送，就是说正常情况下会同时发2个ping。<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">i-&gt;second.con_back-&gt;send_message(<span class="keyword">new</span> MOSDPing(monc-&gt;get_fsid(),</span><br><span class="line">  service.get_osdmap()-&gt;get_epoch(),</span><br><span class="line">  MOSDPing::PING,</span><br><span class="line">  now));</span><br><span class="line"></span><br><span class="line">   <span class="keyword">if</span> (i-&gt;second.con_front)</span><br><span class="line">     i-&gt;second.con_front-&gt;send_message(<span class="keyword">new</span> MOSDPing(monc-&gt;get_fsid(),</span><br><span class="line">     service.get_osdmap()-&gt;get_epoch(),</span><br><span class="line">     MOSDPing::PING,</span><br><span class="line">     now));</span><br></pre></td></tr></table></figure></p><p>未完待续~ ~ ~<br>2017年9月11日01:32:24</p>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;ceph集群中的心跳机制研究&quot;&gt;ceph集群中的心跳机制研究&lt;/h1&gt;&lt;p&gt;基于Ceph 0.94.5版本，进行Ceph集群中的心跳机制进行研究。&lt;br&gt;在ceph中，心跳机制通过ping来实现，用来作为集群中故障检测的方法。分为两类：osd与osd之间的心跳，osd与mon之间的心跳。下面去一探究竟。&lt;/p&gt;
    
    </summary>
    
      <category term="ceph" scheme="http://hetaotao.net/categories/ceph/"/>
    
    
      <category term="ceph" scheme="http://hetaotao.net/tags/ceph/"/>
    
  </entry>
  
  <entry>
    <title>storage</title>
    <link href="http://hetaotao.net/2017/09/03/storage/"/>
    <id>http://hetaotao.net/2017/09/03/storage/</id>
    <published>2017-09-03T03:02:43.000Z</published>
    <updated>2020-05-27T07:47:35.750Z</updated>
    
    <content type="html"><![CDATA[<h1 id="A_mind_map_about_storage">A mind map about storage</h1><p>我个人现在的工作方向是云存储，这要求我既对目前接触的分布式存储方案、技术（<a href="http://docs.ceph.com" target="_blank" rel="noopener">Ceph</a>）有深入的研究，对于存储这个较大的领域的一些基本原理、通用性、本质性的东西也很需要有所了解。先贴一张自己总结的思维导图，以后会基于此图进行补充或者细化。</p><a id="more"></a><p><img src="/uploads/storage.png" alt="storage"></p>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;A_mind_map_about_storage&quot;&gt;A mind map about storage&lt;/h1&gt;&lt;p&gt;我个人现在的工作方向是云存储，这要求我既对目前接触的分布式存储方案、技术（&lt;a href=&quot;http://docs.ceph.com&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;Ceph&lt;/a&gt;）有深入的研究，对于存储这个较大的领域的一些基本原理、通用性、本质性的东西也很需要有所了解。先贴一张自己总结的思维导图，以后会基于此图进行补充或者细化。&lt;/p&gt;
    
    </summary>
    
      <category term="storage" scheme="http://hetaotao.net/categories/storage/"/>
    
    
      <category term="storage, mind map" scheme="http://hetaotao.net/tags/storage-mind-map/"/>
    
  </entry>
  
  <entry>
    <title>About hash function</title>
    <link href="http://hetaotao.net/2017/08/27/hash-function/"/>
    <id>http://hetaotao.net/2017/08/27/hash-function/</id>
    <published>2017-08-27T07:24:38.000Z</published>
    <updated>2017-08-27T08:34:33.377Z</updated>
    
    <content type="html"><![CDATA[<p>日常工作中经常会遇到哈希算法，出于好奇想多了解一些关于哈希的理论。<br>在Ceph中（一种分布式存储系统），从Object到PG的映射就是采用了一种哈希算法，名为“rjenkins”。所以就是从这里作为切入点，看了一些资料。</p><a id="more"></a><h1 id="哈希算法的作用">哈希算法的作用</h1><p>哈希，也称作散列，它的作用其实就是通过一个函数（hash function），将输入值映射为一个输出的值，并且尽量保证这个映射是一对一的。</p><h1 id="哈希算法的好坏">哈希算法的好坏</h1><p>怎样的哈希算法才是一个好的哈希算法？从他的作用或者说目的上看，它最重要的衡量标准是是否有碰撞（collision），或者是否有尽可能少的碰撞。这里有个概念 funneling，翻译成中文是“漏斗效应”[注1]，其实就是很多input被映射到少量的几个output上，产生了大量的碰撞。好的hash算法应该是可以通过测试或者<a href="http://burtleburtle.net/bob/hash/funnels.html" target="_blank" rel="noopener">理论证明</a>这个算法是no funnel的。<br>这里有两个概念：完美哈希函数（PHF，Perfect Hash Function）和最小完美哈希函数（MPHF，Minimal Perfect Hash Function）。完美哈希函数，就是没有冲突的哈希函数，也就是将N个KEY值映射到M个整数上，这里M&gt;=N，并且对于任意的KEY1，KEY2，H(KEY1)！=H(KEY2)。当M==N，则H是最小完美哈希函数。<br>当然它的另一个衡量标准是速度快，前提是在相同硬件条件下。也就是说每次哈希的运算次数少或者消耗的CPU指令周期少。</p><h1 id="哈希模型">哈希模型</h1><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">initialize the internal state;</span><br><span class="line">  <span class="keyword">for</span> (each block of the input)</span><br><span class="line">  &#123;</span><br><span class="line">    combine (the internal state, the current input block);</span><br><span class="line">    mix( the internal state);</span><br><span class="line">  &#125;</span><br><span class="line">  value = postprocess( the internal state );</span><br><span class="line">  <span class="keyword">return</span> (value);</span><br></pre></td></tr></table></figure><p>也就是说一个hash过程主要包括：initialize, combine, mix, postprocess这几个过程。</p><h1 id="参考">参考</h1><ol><li>Jenkins关于他新的hash算法以及相关理论的介绍<br> <a href="http://burtleburtle.net/bob/hash/evahash.html" target="_blank" rel="noopener">http://burtleburtle.net/bob/hash/evahash.html</a> </li><li>几种hash算法的对比<br> <a href="http://burtleburtle.net/bob/hash/examhash.html" target="_blank" rel="noopener">http://burtleburtle.net/bob/hash/examhash.html</a> </li></ol><p>附言：<br>好长时间没写东西了，今天来这里扫扫灰：）</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;日常工作中经常会遇到哈希算法，出于好奇想多了解一些关于哈希的理论。&lt;br&gt;在Ceph中（一种分布式存储系统），从Object到PG的映射就是采用了一种哈希算法，名为“rjenkins”。所以就是从这里作为切入点，看了一些资料。&lt;/p&gt;
    
    </summary>
    
      <category term="algorithm" scheme="http://hetaotao.net/categories/algorithm/"/>
    
    
      <category term="hash, algorithm" scheme="http://hetaotao.net/tags/hash-algorithm/"/>
    
  </entry>
  
  <entry>
    <title>string类型使用小结</title>
    <link href="http://hetaotao.net/2015/12/14/string%E7%B1%BB%E5%9E%8B%E4%BD%BF%E7%94%A8%E5%B0%8F%E7%BB%93/"/>
    <id>http://hetaotao.net/2015/12/14/string类型使用小结/</id>
    <published>2015-12-14T03:00:56.000Z</published>
    <updated>2020-05-27T07:49:16.417Z</updated>
    
    <content type="html"><![CDATA[<p>c++在c的char类型基础上引入了string类，从而更加方便地对字符串进行操作。但是如果是不会使用string类也会带来很多麻烦。在自己编码的基础上总结了几点误区。</p><h2 id="1、char*类型与string类型的相互转换">1、char*类型与string类型的相互转换</h2><p>从char*到string，需要调用string类的构造函数<br>　　如：char* a; string s(a);<br>从string到char*，需要使用string类的c_str()函数<br>　　如：string s = “hello”,  const char* c = s.c_str();</p><a id="more"></a><h2 id="2、一个特殊错误">2、一个特殊错误</h2><p>单步调试没问题，但是一运行就崩溃</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//编译通过，运行崩溃</span></span><br><span class="line"><span class="built_in">string</span> str;</span><br><span class="line">i=<span class="number">0</span>;</span><br><span class="line">freopen(<span class="string">"test_without_punctuation.txt"</span>, <span class="string">"r"</span>, <span class="built_in">stdin</span>);</span><br><span class="line"><span class="keyword">char</span> c;</span><br><span class="line"><span class="keyword">while</span>( <span class="built_in">scanf</span>(<span class="string">"%c"</span>, &amp;str[i]) != EOF) &#123;</span><br><span class="line"><span class="keyword">if</span>(str[i] &gt;= <span class="string">'a'</span> &amp;&amp; str[i] &lt;= <span class="string">'z'</span>)</span><br><span class="line">total_len += MC[str[i]-<span class="string">'a'</span>].length();</span><br><span class="line"><span class="comment">//cout &lt;&lt; total_len &lt;&lt; ' ' &lt;&lt; i &lt;&lt; endl;</span></span><br><span class="line">++i;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//编译通过，运行正确！</span></span><br><span class="line"><span class="built_in">string</span> str;</span><br><span class="line">i=<span class="number">0</span>;</span><br><span class="line">freopen(<span class="string">"test_without_punctuation.txt"</span>, <span class="string">"r"</span>, <span class="built_in">stdin</span>);</span><br><span class="line"><span class="keyword">char</span> c;</span><br><span class="line"><span class="keyword">while</span>( <span class="built_in">scanf</span>(<span class="string">"%c"</span>, &amp;c) != EOF) &#123;</span><br><span class="line">str+=c;</span><br><span class="line"><span class="keyword">if</span>(str[i] &gt;= <span class="string">'a'</span> &amp;&amp; str[i] &lt;= <span class="string">'z'</span>)</span><br><span class="line">total_len += MC[str[i]-<span class="string">'a'</span>].length();</span><br><span class="line"><span class="comment">//cout &lt;&lt; total_len &lt;&lt; ' ' &lt;&lt; i &lt;&lt; endl;</span></span><br><span class="line">++i;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>原因可能在于对string类型进行读入的时候，即使用scanf()时，string不支持对单个字符的读入！</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;c++在c的char类型基础上引入了string类，从而更加方便地对字符串进行操作。但是如果是不会使用string类也会带来很多麻烦。在自己编码的基础上总结了几点误区。&lt;/p&gt;
&lt;h2 id=&quot;1、char*类型与string类型的相互转换&quot;&gt;1、char*类型与string类型的相互转换&lt;/h2&gt;&lt;p&gt;从char*到string，需要调用string类的构造函数&lt;br&gt;　　如：char* a; string s(a);&lt;br&gt;从string到char*，需要使用string类的c_str()函数&lt;br&gt;　　如：string s = “hello”,  const char* c = s.c_str();&lt;/p&gt;
    
    </summary>
    
      <category term="c++" scheme="http://hetaotao.net/categories/c/"/>
    
    
      <category term="string类型" scheme="http://hetaotao.net/tags/string%E7%B1%BB%E5%9E%8B/"/>
    
  </entry>
  
  <entry>
    <title>Huffman编码与Morse编码</title>
    <link href="http://hetaotao.net/2015/12/14/Huffman%E7%BC%96%E7%A0%81%E4%B8%8EMorse%E7%BC%96%E7%A0%81/"/>
    <id>http://hetaotao.net/2015/12/14/Huffman编码与Morse编码/</id>
    <published>2015-12-14T01:31:44.000Z</published>
    <updated>2020-05-27T07:41:03.309Z</updated>
    
    <content type="html"><![CDATA[<p>最近做课程设计，接触到了Huffman编码与Morse编码。在此总结，分享。之前认为编码是个很神奇的存在，现在能够用代码实现，感觉还是很开心的！</p><h1 id="一、Huffman编码">一、Huffman编码</h1><h2 id="1、概念（摘自wikipedia）">1、概念（摘自<a href="https://zh.wikipedia.org/wiki/%E9%9C%8D%E5%A4%AB%E6%9B%BC%E7%BC%96%E7%A0%81" target="_blank" rel="noopener">wikipedia</a>）</h2><p>　　霍夫曼编码（Huffman Coding）是一种编码方式，是一种用于无损数据压缩的熵编码（权编码）演算法。也称“哈夫曼编码”，“赫夫曼编码”。1952年，David A. Huffman在麻省理工攻读博士时所发明的，并发表于《一种构建极小多馀编码的方法》（A Method for the Construction of Minimum-Redundancy Codes）一文。</p><p>　　在计算机资料处理中，霍夫曼编码使用变长编码表对源符号（如文件中的一个字母）进行编码，其中变长编码表是通过一种评估来源符号出现机率的方法得到的，出现机率高的字母使用较短的编码，反之出现机率低的则使用较长的编码，这便使编码之后的字符串的平均长度、期望值降低，从而达到无损压缩数据的目的。</p><a id="more"></a><p>　　例如，在英文中，e的出现机率最高，而z的出现概率则最低。当利用霍夫曼编码对一篇英文进行压缩时，e极有可能用一个位元来表示，而z则可能花去25个位元（不是26）。用普通的表示方法时，每个英文字母均占用一个字节，即8个位元。二者相比，e使用了一般编码的1/8的长度，z则使用了3倍多。倘若我们能实现对于英文中各个字母出现概率的较准确的估算，就可以大幅度提高无损压缩的比例。</p><p>　　霍夫曼树又称最优二叉树，是一种带权路径长度最短的二叉树。所谓树的带权路径长度，就是树中所有的叶结点的权值乘上其到根结点的路径长度（若根结点为0层，叶结点到根结点的路径长度为叶结点的层数）。树的路径长度是从树根到每一结点的路径长度之和，记为WPL=（W1<em>L1+W2</em>L2+W3<em>L3+…+Wn</em>Ln），N个权值Wi（i=1,2,…n）构成一棵有N个叶结点的二叉树，相应的叶结点的路径长度为Li（i=1,2,…n）。可以证明霍夫曼树的WPL是最小的。</p><p>  <img src="/uploads/HuffmanTree.png" alt="HuffmanTree"></p><h2 id="2、算法">2、算法</h2><p>构造huffman树的哈夫曼算法如下：</p><p>  （1）n节点的权值｛w1、w2、·····，wn｝构成n棵二叉树集合F=｛T1，T2，···，Tn｝，每棵二叉树Ti只有一个带权为Wi的根节点，左右孩子均空。</p><p>  （2）在F中选取两棵根节点权值最小的作为树的左右孩子构造一棵新的二叉树，且置根节点的权值为左右孩子权值之和，在F中删除这两棵树，新二叉树放于集合F中。</p><p>  （3）重复（2），直到F中只有一棵树为止，这棵树就是huffman树。</p><h2 id="3、实现">3、实现</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">说明：</span></span><br><span class="line"><span class="comment">    1、此程序用来构建Huffman树，对英文字母a-z根据词频统计生成Huffman码表；</span></span><br><span class="line"><span class="comment">    2、对指定文段进行Huffman编码，并计算编码总长度和平均码长；</span></span><br><span class="line"><span class="comment">    3、IDE为Dev C++ 5.4.1</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//构造树节点，parent作为判断这棵树是否在集合中，</span></span><br><span class="line"><span class="comment">//lchild为权值最小节点，rchild为权值第二小的节点，weight为节点的权值。</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line"><span class="keyword">int</span> weight;</span><br><span class="line"><span class="keyword">int</span> parent, lchild, rchild;</span><br><span class="line">&#125;HuffmanNode, *HuffmanTree;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">char</span> **HuffmanCode;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">HuffmanCoding</span><span class="params">(HuffmanTree &amp;HT, HuffmanCode &amp;HC, <span class="keyword">float</span> *w, <span class="keyword">int</span> n)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">HuffmanDecoding</span><span class="params">(HuffmanCode &amp;HC, <span class="keyword">char</span>* code_str, <span class="keyword">char</span>* decode_str)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">select</span><span class="params">(HuffmanTree HT, <span class="keyword">int</span> n, <span class="keyword">int</span> &amp;s1, <span class="keyword">int</span> &amp;s2)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//全局变量 </span></span><br><span class="line"><span class="keyword">float</span> w[<span class="number">26</span>] = &#123;<span class="number">8.167</span>, <span class="number">1.492</span>, <span class="number">2.782</span>, <span class="number">4.253</span>, <span class="number">12.702</span>, <span class="number">2.228</span>, <span class="number">2.015</span>, </span><br><span class="line"><span class="number">6.094</span>, <span class="number">6.966</span>, <span class="number">0.153</span>, <span class="number">0.772</span>, <span class="number">4.025</span>, <span class="number">2.406</span>, <span class="number">6.749</span>, <span class="number">7.507</span>, <span class="number">1.929</span>,</span><br><span class="line"><span class="number">0.095</span>, <span class="number">5.987</span>, <span class="number">6.327</span>, <span class="number">9.056</span>, <span class="number">2.758</span>, <span class="number">0.978</span>, <span class="number">2.361</span>, <span class="number">0.150</span>, <span class="number">1.974</span>, <span class="number">0.074</span>&#125;;</span><br><span class="line">HuffmanTree HT;</span><br><span class="line">HuffmanCode HC;</span><br><span class="line"></span><br><span class="line"><span class="comment">//主函数 </span></span><br><span class="line"><span class="comment">//-----------------------------------------------------</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span> <span class="params">(<span class="keyword">void</span>)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="comment">//string code_str;</span></span><br><span class="line"><span class="built_in">string</span> str;</span><br><span class="line"><span class="keyword">int</span> i=<span class="number">0</span>;</span><br><span class="line"><span class="keyword">double</span> total_len=<span class="number">0.0</span>, average_len=<span class="number">0.0</span>;</span><br><span class="line"></span><br><span class="line">HuffmanCoding(HT, HC, w, <span class="number">26</span>);</span><br><span class="line"></span><br><span class="line">freopen(<span class="string">"test_without_punctuation.txt"</span>, <span class="string">"r"</span>, <span class="built_in">stdin</span>);</span><br><span class="line"><span class="keyword">char</span> c;</span><br><span class="line"><span class="keyword">while</span>( <span class="built_in">scanf</span>(<span class="string">"%c"</span>, &amp;c) != EOF) &#123;</span><br><span class="line">str+=c;</span><br><span class="line"><span class="keyword">if</span>(str[i] &gt;= <span class="string">'a'</span> &amp;&amp; str[i] &lt;= <span class="string">'z'</span>)</span><br><span class="line">total_len += <span class="built_in">strlen</span>(HC[str[i]-<span class="string">'a'</span>+<span class="number">1</span>]);</span><br><span class="line"><span class="comment">//cout &lt;&lt; total_len &lt;&lt; ' ' &lt;&lt; i &lt;&lt; endl;</span></span><br><span class="line">++i;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//输出 </span></span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">"Total length of HuffmanCoding is: "</span> &lt;&lt; total_len &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">average_len = total_len / i;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">"Average length of HuffmanCoding is: "</span> &lt;&lt; average_len &lt;&lt; <span class="built_in">endl</span>; </span><br><span class="line"></span><br><span class="line"><span class="built_in">free</span>(HC);</span><br><span class="line"><span class="built_in">free</span>(HT);</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//-------------------------------------------------------</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//Huffman编码函数 </span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">HuffmanCoding</span><span class="params">(HuffmanTree &amp;HT, HuffmanCode &amp;HC, <span class="keyword">float</span> *w, <span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> m = <span class="number">2</span>*n<span class="number">-1</span>;</span><br><span class="line"><span class="keyword">int</span> s1, s2;</span><br><span class="line">HT = (HuffmanNode*)<span class="built_in">malloc</span>((m+<span class="number">1</span>)*<span class="keyword">sizeof</span>(HuffmanNode));</span><br><span class="line"><span class="built_in">memset</span>(HT, <span class="number">0</span>, (m+<span class="number">1</span>)*<span class="keyword">sizeof</span>(HuffmanNode));</span><br><span class="line"><span class="comment">//初始化权值 </span></span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>; i&lt;=n; i++)</span><br><span class="line">HT[i].weight = *w++;</span><br><span class="line"><span class="comment">//创建Huffman tree</span></span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=n+<span class="number">1</span>; i&lt;=m; i++) &#123;</span><br><span class="line"><span class="comment">//选择剩余节点中权值最小的节点s1,s2</span></span><br><span class="line">select(HT, i<span class="number">-1</span>, s1, s2);</span><br><span class="line">HT[s1].parent = i;</span><br><span class="line">HT[s2].parent = i;</span><br><span class="line">HT[i].lchild = s1;</span><br><span class="line">HT[i].rchild = s2;</span><br><span class="line">HT[i].weight = HT[s1].weight + HT[s2].weight;</span><br><span class="line">&#125; </span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> start, c, f;</span><br><span class="line">HC = (HuffmanCode)<span class="built_in">malloc</span>((n+<span class="number">1</span>)*<span class="keyword">sizeof</span>(<span class="keyword">char</span>*));</span><br><span class="line"><span class="keyword">char</span>* cd = (<span class="keyword">char</span>*)<span class="built_in">malloc</span>(n*<span class="keyword">sizeof</span>(<span class="keyword">char</span>));</span><br><span class="line">cd[n<span class="number">-1</span>] = <span class="string">'\0'</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>; i&lt;=n; i++) &#123;</span><br><span class="line"></span><br><span class="line">start = n<span class="number">-1</span>;</span><br><span class="line"><span class="keyword">for</span>(c=i, f=HT[i].parent; f!=<span class="number">0</span>; c=f,f=HT[f].parent)</span><br><span class="line"><span class="keyword">if</span>(HT[f].lchild == c)</span><br><span class="line">cd[--start] = <span class="string">'0'</span>;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">cd[--start] = <span class="string">'1'</span>;</span><br><span class="line">HC[i] = (<span class="keyword">char</span>*)<span class="built_in">malloc</span>((n-start)*<span class="keyword">sizeof</span>(<span class="keyword">char</span>));</span><br><span class="line"><span class="built_in">strcpy</span>(HC[i], &amp;cd[start]);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//输出a-z的Huffman编码</span></span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">"The HuffmanCode of a to z:\n"</span>; </span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>; i&lt;=n; i++)</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; (<span class="keyword">char</span>)(<span class="string">'a'</span>+i<span class="number">-1</span>) &lt;&lt; <span class="string">" : "</span> &lt;&lt; HC[i] &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line"><span class="built_in">free</span>(cd);</span><br><span class="line">&#125; </span><br><span class="line"><span class="comment">//最小权值选择函数 </span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">select</span><span class="params">(HuffmanTree HT, <span class="keyword">int</span> n, <span class="keyword">int</span> &amp;s1, <span class="keyword">int</span> &amp;s2)</span> </span>&#123;</span><br><span class="line">s1 = <span class="number">1</span>;</span><br><span class="line">s2 = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">int</span> min = <span class="number">9999</span>;</span><br><span class="line"><span class="keyword">int</span> i;</span><br><span class="line"></span><br><span class="line"><span class="comment">//找s1 </span></span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> p = <span class="number">1</span>; p&lt;=n; p++) &#123;</span><br><span class="line"><span class="keyword">if</span>(<span class="number">0</span> == HT[p].parent &amp;&amp; min &gt;= HT[p].weight) &#123;</span><br><span class="line">s1 = p;</span><br><span class="line">min = HT[p].weight;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//找s2</span></span><br><span class="line">min = <span class="number">9999</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> q = <span class="number">1</span>; q&lt;=n; q++) &#123;</span><br><span class="line"><span class="keyword">if</span>(<span class="number">0</span> == HT[q].parent &amp;&amp; min &gt;= HT[q].weight) &#123;</span><br><span class="line"><span class="keyword">if</span>(q == s1)</span><br><span class="line"><span class="keyword">continue</span>;</span><br><span class="line">s2 = q;</span><br><span class="line">min = HT[q].weight;</span><br><span class="line">&#125;</span><br><span class="line">&#125; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//Huffman译码函数,仅供参考，有BUG</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">HuffmanDecoding</span><span class="params">(HuffmanCode &amp;HC, <span class="keyword">char</span>* code_str, <span class="keyword">char</span>* decode_str)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="comment">//char decode_str[30];</span></span><br><span class="line"><span class="keyword">int</span> j=<span class="number">0</span>,k=<span class="number">0</span>; <span class="comment">//j为a-z序号，k为每段译码的序号 </span></span><br><span class="line"><span class="keyword">int</span> t=<span class="number">0</span>,s=<span class="number">0</span>; <span class="comment">//t变量作为检查是否编码被排除，s作为解码之后的字符数组序号 </span></span><br><span class="line"><span class="keyword">int</span> cnt=<span class="number">0</span>; </span><br><span class="line"><span class="keyword">bool</span> is_code[<span class="number">26</span>];</span><br><span class="line"><span class="keyword">int</span> test[<span class="number">26</span>];</span><br><span class="line"><span class="built_in">memset</span>(test, <span class="number">0</span>, <span class="keyword">sizeof</span>(test));</span><br><span class="line"><span class="built_in">memset</span>(is_code, <span class="literal">true</span>, <span class="keyword">sizeof</span>(is_code));</span><br><span class="line"><span class="keyword">int</span> len = <span class="built_in">strlen</span>(code_str);</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;len; i++) &#123;</span><br><span class="line"><span class="keyword">for</span>(j=<span class="number">1</span>; j&lt;=<span class="number">26</span>; j++)</span><br><span class="line"><span class="keyword">if</span>(k&gt;=<span class="built_in">strlen</span>(HC[j]) || code_str[i] != HC[j][k])</span><br><span class="line">is_code[j<span class="number">-1</span>] = <span class="literal">false</span>;</span><br><span class="line">k++;</span><br><span class="line">cnt=<span class="number">0</span>;</span><br><span class="line"><span class="built_in">memset</span>(test, <span class="number">0</span>, <span class="keyword">sizeof</span>(test));</span><br><span class="line"><span class="keyword">for</span>(t=<span class="number">0</span>; t&lt;<span class="number">26</span>; t++)</span><br><span class="line"><span class="keyword">if</span>(is_code[t]) &#123;</span><br><span class="line">cnt++;</span><br><span class="line">test[cnt] = t;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span>(cnt == <span class="number">1</span> || (cnt == <span class="number">2</span> &amp;&amp; i == <span class="number">15</span>)) &#123;</span><br><span class="line"><span class="keyword">for</span>(t=<span class="number">0</span>; t&lt;<span class="number">26</span>; t++)</span><br><span class="line"><span class="keyword">if</span>(is_code[t]) &#123;</span><br><span class="line"><span class="keyword">if</span>(i == <span class="number">15</span>)</span><br><span class="line">decode_str[s++] = <span class="string">'a'</span>+<span class="number">7</span>;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">decode_str[s++] = <span class="string">'a'</span>+t;</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br><span class="line">k=<span class="number">0</span>;</span><br><span class="line"><span class="built_in">memset</span>(is_code, <span class="literal">true</span>, <span class="keyword">sizeof</span>(is_code));</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; decode_str &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="二、Morse编码">二、Morse编码</h1><h2 id="1、概念(摘自wikipedia)">1、概念(摘自<a href="https://zh.wikipedia.org/wiki/%E6%91%A9%E5%B0%94%E6%96%AF%E7%94%B5%E7%A0%81" target="_blank" rel="noopener">wikipedia</a>)</h2><p>　　摩尔斯电码（英语：Morse Code）是一种时通时断的信号代码，通过不同的排列顺序来表达不同的英文字母、数字和标点符号。是由美国人萨缪尔·摩尔斯在1836年发明。</p><p>　　摩尔斯电码是一种早期的数码化通信形式，但是它不同于现代只使用0和1两种状态的二进制代码，它的代码包括五种：<br>　　1.点（.）<br>　　2.划（-）<br>　　3.每个字符间短的停顿（在点和划之间的停顿）<br>　　4.每个词之间中等的停顿<br>　　5.以及句子之间长的停顿</p><p>A-Z的Morse编码如下:</p><p><img src="/uploads/Morse code.png" alt="Morse code"></p><h2 id="2、算法-1">2、算法</h2><p>即将每个英文字母转化为对应的Morse码，在一个字母的内部、字母之间、单词之间都需要添加特定个数的空格。</p><h2 id="3、实现-1">3、实现</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">说明：</span></span><br><span class="line"><span class="comment">    1、根据英文字母a-z的Morse码表，对指定文段进行Morse编码，并计算编码总长度和平均码长；</span></span><br><span class="line"><span class="comment">    3、IDE为Dev C++ 5.4.1</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;fstream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span> <span class="params">(<span class="keyword">void</span>)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="built_in">string</span> str;</span><br><span class="line"><span class="built_in">string</span> code_str;</span><br><span class="line"><span class="built_in">string</span> MC[<span class="number">26</span>];</span><br><span class="line"><span class="keyword">double</span> total_len=<span class="number">0.0</span>;</span><br><span class="line"><span class="keyword">double</span> average_len=<span class="number">0.0</span>;</span><br><span class="line"><span class="keyword">int</span> i=<span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//按行读取文件</span></span><br><span class="line"><span class="function">ifstream <span class="title">fin</span><span class="params">( <span class="string">"Morsecode.txt"</span> )</span></span>;  </span><br><span class="line"><span class="keyword">while</span> ( getline(fin, MC[i]) ) i++;</span><br><span class="line">fin.close(); </span><br><span class="line"><span class="comment">//输出morse码表 </span></span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">"The MorseCode of a to z:\n"</span>; </span><br><span class="line"><span class="keyword">for</span>(i=<span class="number">0</span>; i&lt;<span class="number">26</span>; i++)</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; (<span class="keyword">char</span>)(<span class="string">'a'</span>+i) &lt;&lt; <span class="string">" : "</span> &lt;&lt; MC[i] &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"><span class="comment">//输出重定向并统计文段morse码总长度 </span></span><br><span class="line">i=<span class="number">0</span>;</span><br><span class="line">freopen(<span class="string">"test_without_punctuation.txt"</span>, <span class="string">"r"</span>, <span class="built_in">stdin</span>);</span><br><span class="line"><span class="keyword">char</span> c;</span><br><span class="line"><span class="keyword">while</span>( <span class="built_in">scanf</span>(<span class="string">"%c"</span>, &amp;c) != EOF) &#123;</span><br><span class="line">str+=c;</span><br><span class="line"><span class="keyword">if</span>(str[i] &gt;= <span class="string">'a'</span> &amp;&amp; str[i] &lt;= <span class="string">'z'</span>)</span><br><span class="line">total_len += MC[str[i]-<span class="string">'a'</span>].length();</span><br><span class="line"><span class="comment">//cout &lt;&lt; total_len &lt;&lt; ' ' &lt;&lt; i &lt;&lt; endl;</span></span><br><span class="line">++i;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//输出 </span></span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">"Total length of MorseCoding is: "</span> &lt;&lt; total_len &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">average_len = total_len / i;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">"Average length of MorseCoding is: "</span> &lt;&lt; average_len &lt;&lt; <span class="built_in">endl</span>; </span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Reference:<br>[1].<a href="https://zh.wikipedia.org/wiki/%E9%9C%8D%E5%A4%AB%E6%9B%BC%E7%BC%96%E7%A0%81" target="_blank" rel="noopener">https://zh.wikipedia.org/wiki/%E9%9C%8D%E5%A4%AB%E6%9B%BC%E7%BC%96%E7%A0%81</a><br>[2].<a href="http://blog.csdn.net/qyee16/article/details/6664377" target="_blank" rel="noopener">http://blog.csdn.net/qyee16/article/details/6664377</a><br>[3].<a href="https://zh.wikipedia.org/wiki/%E6%91%A9%E5%B0%94%E6%96%AF%E7%94%B5%E7%A0%81" target="_blank" rel="noopener">https://zh.wikipedia.org/wiki/%E6%91%A9%E5%B0%94%E6%96%AF%E7%94%B5%E7%A0%81</a></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;最近做课程设计，接触到了Huffman编码与Morse编码。在此总结，分享。之前认为编码是个很神奇的存在，现在能够用代码实现，感觉还是很开心的！&lt;/p&gt;
&lt;h1 id=&quot;一、Huffman编码&quot;&gt;一、Huffman编码&lt;/h1&gt;&lt;h2 id=&quot;1、概念（摘自wikipedia）&quot;&gt;1、概念（摘自&lt;a href=&quot;https://zh.wikipedia.org/wiki/%E9%9C%8D%E5%A4%AB%E6%9B%BC%E7%BC%96%E7%A0%81&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;wikipedia&lt;/a&gt;）&lt;/h2&gt;&lt;p&gt;　　霍夫曼编码（Huffman Coding）是一种编码方式，是一种用于无损数据压缩的熵编码（权编码）演算法。也称“哈夫曼编码”，“赫夫曼编码”。1952年，David A. Huffman在麻省理工攻读博士时所发明的，并发表于《一种构建极小多馀编码的方法》（A Method for the Construction of Minimum-Redundancy Codes）一文。&lt;/p&gt;
&lt;p&gt;　　在计算机资料处理中，霍夫曼编码使用变长编码表对源符号（如文件中的一个字母）进行编码，其中变长编码表是通过一种评估来源符号出现机率的方法得到的，出现机率高的字母使用较短的编码，反之出现机率低的则使用较长的编码，这便使编码之后的字符串的平均长度、期望值降低，从而达到无损压缩数据的目的。&lt;/p&gt;
    
    </summary>
    
      <category term="编码" scheme="http://hetaotao.net/categories/%E7%BC%96%E7%A0%81/"/>
    
    
      <category term="编码、Huffman" scheme="http://hetaotao.net/tags/%E7%BC%96%E7%A0%81%E3%80%81Huffman/"/>
    
  </entry>
  
</feed>
